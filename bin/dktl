#!/bin/bash

# Set Drupal version if it isn't set.
DRUPAL_VERSION=${DRUPAL_VERSION:-"V8"}

# Which platform we're running on (linux and mac supported)
if [ -z $PLATFORM ]; then
  PLATFORM=`uname` && export PLATFORM
fi

# Determine whether we want to run inside the docker container or in the host machine.
if [ -z $DKTL_MODE ] || [ "$DKTL_MODE" = "DOCKER" ]; then
  DKTL_MODE="DOCKER"
elif [ "$DKTL_MODE" = "HOST" ]; then
  DKTL_MODE="HOST"
else
  echo "Incorrect DKTL_MODE set to ${DKTL_MODE}. Appropriate values are 'DOCKER'and 'HOST'."
  exit 1
fi

# Check dependencies.
if [ "$DKTL_MODE" = "DOCKER" ]; then
  if [ -z `which docker` ] || [ -z `which docker-compose` ]; then
      echo "docker and docker-compose are required. Exiting."
      exit 1
  fi
else
  if [ -z `which php` ] || [ -z `which composer` ] || [ -z `which drush` ]; then
    echo "php, composer and drush are required. Exiting."
    exit 1
  fi
fi

# Function to find project root so we can run from anywhere
find-up () {
  path=$(pwd)
  while [[ "$path" != "" && ! -e "$path/$1" ]]; do
    path=${path%/*}
  done
  echo "$path"
}

DKTL_PROJECT_DIRECTORY=$(find-up dktl.yml)
if [ -z "$DKTL_PROJECT_DIRECTORY" ]; then
  if [ "$1" = "init" ]; then
    DKTL_PROJECT_DIRECTORY=$(pwd)
  else
    echo "DKTL is running outside of a DKTL project. Run dktl init in the project directory first."
    exit 1
  fi
fi
export DKTL_PROJECT_DIRECTORY

DKTL_DIRECTORY=$(which dktl)

if [[ -L $(which dktl) ]]; then
  # readlink command needs -f to work properly in linux
  if [ "$PLATFORM" = "Linux" ]; then RL_OPT='-f'; fi;
  DKTL_DIRECTORY=$(readlink $RL_OPT $DKTL_DIRECTORY)
fi
DKTL_DIRECTORY=$(dirname $(dirname $DKTL_DIRECTORY))
export DKTL_DIRECTORY

if [ -z "$DKTL_SLUG" ]; then
  DKTL_SLUG=${DKTL_PROJECT_DIRECTORY##*/}
  DKTL_SLUG=${DKTL_SLUG//-/}
  DKTL_SLUG=${DKTL_SLUG//_/}
  DKTL_SLUG=$(echo ${DKTL_SLUG} | tr -d '[:space:]' | tr "[A-Z]" "[a-z]") # Mixed case dirs cause issue with docker image names
  export DKTL_SLUG
fi

# Setup for Docker mode and Docker-specific commands.
if [ "$DKTL_MODE" = "DOCKER" ]; then
  WEB_DOMAIN="localtest.me"
  # Will use dktl-proxy to use {Slug}.{Web Domain}.
  export DKTL_PROXY_DOMAIN="$DKTL_SLUG.$WEB_DOMAIN"

  # Helper dktl docker mode functions.
  function dktl_proxy_connect () {
    network="${DKTL_SLUG}_default"
    if docker network connect "$network" dktl-proxy >/dev/null 2>&1; then
      echo "Connected dktl-proxy to \"${network}\" network."
    fi
  }

  function dc_up () {
    # Check containers state, Run is missing, make sure dktl-proxy is connected
    # to the same network.
    containers=$($BASE_DOCKER_COMPOSE_COMMAND ps -q)
    if [ -z "$containers" ]; then
      echo "Starting docker containers."
      $BASE_DOCKER_COMPOSE_COMMAND up -d

      dktl_proxy_connect
    fi
  }

  # Make sure the proxy container is up.
  proxy_service_ps=$(docker ps -f 'name=dktl-proxy' --format '{{.Names}}' 2>/dev/null)

  if [[ -z $proxy_service_ps ]]; then
    echo "Running dktl-proxy.."
    # Make sure no old instance is using the name.
    docker rm dktl-proxy >/dev/null 2>&1

    if ! docker run -d -p 8080:8080 -p 80:80 -p 433:433 \
      -v '/var/run/docker.sock:/var/run/docker.sock' \
      --name 'dktl-proxy' \
      traefik:v2.0 \
      "--log.level=INFO" "--api.insecure=true" "--providers.docker=true" "--providers.docker.exposedbydefault=false" "--entrypoints.web.address=:80" "--entrypoints.websecure.address=:443" \
      >/dev/null; \
    then
      echo -n "Failed to start the dktl-proxy container..."
    fi

  fi

  COMMON_CONF="$DKTL_DIRECTORY/assets/docker/docker-compose.common.yml"
  OVERRIDES_CONF="$DKTL_PROJECT_DIRECTORY/src/docker/docker-compose.overrides.yml"
  BASE_DOCKER_COMPOSE_COMMAND="docker-compose -f $COMMON_CONF -p "${DKTL_SLUG}" --project-directory $DKTL_PROJECT_DIRECTORY"

  if [ -f $OVERRIDES_CONF ]; then
    BASE_DOCKER_COMPOSE_COMMAND+=" -f $OVERRIDES_CONF"
  fi

  # Check for interactive shell if DKTL_NO_PTY is not set
  if [ ! -z "$DKTL_NO_PTY" ]; then
    EXEC_OPTS='-T'
  elif [ -t 1 ]; then
    EXEC_OPTS=''
  else
    EXEC_OPTS='-T';
  fi

  # Run docker commands immediately then exit
  if [ "$1" = "docker:compose" ] || [ "$1" = "dc" ]; then
    dc_up

    $BASE_DOCKER_COMPOSE_COMMAND "${@:2}"
    exit 0
  elif [ "$1" = "url" ] || [ "$1" = "docker:url" ]; then
    echo "http://$DKTL_PROXY_DOMAIN"
    exit 0
  elif [ "$1" = "surl" ] || [ "$1" = "docker:surl" ]; then
    echo "https://$DKTL_PROXY_DOMAIN"
    exit 0
  elif [ "$1" = "uli" ]; then
    dc_up

    dktl drush uli --uri=`dktl url`
    exit 0
  elif [ "$1" = "suli" ]; then
    dc_up

    dktl drush uli --uri=`dktl surl`
    exit 0
  elif [ "$1" = "down" ]; then
    network="${DKTL_SLUG}_default"

    if docker network disconnect "$network" dktl-proxy >/dev/null 2>&1; then
      echo "Disconnected dktl-proxy from \"${network}\" network."
    fi

    $BASE_DOCKER_COMPOSE_COMMAND down "${@:2}"
    exit 0
  elif [ "$1" = "dktl-proxy:connect" ]; then
    dktl_proxy_connect
    # Restart container to refresh config.
    $BASE_DOCKER_COMPOSE_COMMAND restart
    exit 0
  elif [ "$1" = "dktl-proxy:kill" ]; then
    echo "Removing dktl-proxy ..."
    docker stop dktl-proxy >/dev/null 2>&1
    docker rm dktl-proxy >/dev/null 2>&1
    exit 0
  fi

  # At this point, we will need to have the docker-compose environment up and
  # running.
  dc_up

  # The containers are running, set DKTL inside the cli container.
  ALIAS="$($BASE_DOCKER_COMPOSE_COMMAND exec $EXEC_OPTS cli which dktl)"
  if [ -z "$ALIAS" ]; then
    $BASE_DOCKER_COMPOSE_COMMAND exec $EXEC_OPTS cli chmod 777 /usr/local/dkan-tools/bin/dktl
    $BASE_DOCKER_COMPOSE_COMMAND exec $EXEC_OPTS cli ln -s /usr/local/dkan-tools/bin/dktl /usr/local/bin/dktl
  fi

  # Proxy pass to internal DKTL and save exit status.
  $BASE_DOCKER_COMPOSE_COMMAND exec $EXEC_OPTS cli env DRUPAL_VERSION="$DRUPAL_VERSION" dktl "$1" "${@:2}"
  exit_status=$?

  # Reset web and cli containers if xdebug.
  if [ $? -eq 0 ] && [[ $1 == "xdebug"* ]]; then
    $BASE_DOCKER_COMPOSE_COMMAND restart web
    $BASE_DOCKER_COMPOSE_COMMAND restart cli
  fi

  if [ -z "$DKTL_CHOWN" ] || [ "$DKTL_CHOWN" = "TRUE" ]; then
    # Docker creates files that appear as owned by root on host. Fix:
    if [ -n "$(find "$DKTL_PROJECT_DIRECTORY" -user root -print -quit)" ]; then
        $BASE_DOCKER_COMPOSE_COMMAND exec $EXEC_OPTS cli chown -R `id -u`:`id -g` /var/www
    fi
  fi

  # Now that we've run some cleanup...
  # if we encountered a non-zero exit status during the docker exec, pass it on.
  if [ $exit_status -ne 0 ]; then
    exit $exit_status
  fi
elif [ "$DKTL_MODE" = "HOST" ]; then
  if [[ "$1" == "docker"* ]] || [ "$1" = "dc" ]; then
    echo "${1} is not available in 'HOST' mode"
    exit 1
  fi

  # Check whether dkan-tools' dependencies have been initialized.
  VENDOR="$(ls -lha $DKTL_DIRECTORY | grep vendor)"
  if [ -z "$VENDOR" ]; then
    echo "Composer Install"
    composer install --working-dir=$DKTL_DIRECTORY
  fi


  # For several commands, we want to insert a "--" to pass all arguments as an array.

  case $1 in
      drush | phpunit | *test* )
          php $DKTL_DIRECTORY/bin/app.php $1 -- "${@:2}"
          ;;
      *)
          php $DKTL_DIRECTORY/bin/app.php $1 "${@:2}"
          ;;
  esac
fi
